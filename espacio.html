<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>3D Fireflies with Zoom Panels Effect</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://unpkg.com/lenis@1.2.3/dist/lenis.min.js"></script>
  <style>
    body {
      margin: 0;
      background-color: #000;
      overflow-x: hidden;
      height: 20000px; /* Espacio amplio para realizar scroll */
      font-family: Arial, sans-serif;
    }
    
    canvas {
      position: fixed;
      top: 0;
      left: 0;
      display: block;
      z-index: 1;
    }
  </style>
</head>
<body>
  
  <script>
    (function() {
      // --- Configuración inicial de Three.js ---
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      document.body.appendChild(renderer.domElement);
      
      // Definición de colores base para la mezcla
      const colorRosa = new THREE.Color(255 / 255, 150 / 255, 180 / 255);
      const colorMorado = new THREE.Color(180 / 255, 100 / 255, 255 / 255);
      
      // Variables para gestionar el scroll y animación
      const maxScroll = document.body.scrollHeight - window.innerHeight;
      let scrollPosition = 0;
      let targetCameraZ = 0;
      let currentPanelIndex = 0;
      
      // --- Configuración de los Fireflies ---
      const fireflyCount = 1000;
      const fireflies = [];
      
      // --- Configuración de los paneles ---
      const panels = [];
      const panelCount = 9; // Загальна кількість панелей
      
      // Variables для контролю розташування панелей
      const panelDepthSpacing = 500; // Відстань між панелями по осі Z
      const centeredWidth = 300;     // Ширина панелей, що розташовані по центру
      const altWidth = 200;          // Менша ширина для чергування зліва/справа
      const panelHeight = 200;
      
      // Функція для створення текстури "firefly" з радіальним градієнтом
      const createFireflyTexture = () => {
        const canvas = document.createElement('canvas');
        canvas.width = canvas.height = 32;
        const context = canvas.getContext('2d');
        const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
        gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
        gradient.addColorStop(0.3, 'rgba(255, 255, 255, 0.8)');
        gradient.addColorStop(0.7, 'rgba(255, 255, 255, 0.3)');
        gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
        context.fillStyle = gradient;
        context.fillRect(0, 0, 32, 32);
        return canvas;
      };

      const fireflyTexture = new THREE.CanvasTexture(createFireflyTexture());
      
      // Material базовий для fireflies
      const fireflyMaterial = new THREE.SpriteMaterial({
        map: fireflyTexture,
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthTest: false
      });
      
      // Функція для створення панелей у 3D-просторі
      const createPanels = () => {
        // Видалення існуючих панелей
        panels.forEach(p => scene.remove(p.mesh));
        panels.length = 0;
        
        for (let i = 0; i < panelCount; i++) {
          let x = 0;
          let width = centeredWidth;
          // Перші три панелі по центру: i = 0,1,2  
          // Чотири наступні: i = 3,4,5,6 чергування зліва/справа з меншою шириною
          if (i >= 3 && i <= 6) {
            width = altWidth;
            // Групове індексування для чергування: 0 – ліва, 1 – права, 2 – ліва, 3 – права
            if ((i - 3) % 2 === 0) {
              x = -150; // позиція зліва
            } else {
              x = 150;  // позиція справа
            }
          }
          // Останні дві панелі (i = 7,8) по центру
          
          const y = 0;
          const z = -(i * panelDepthSpacing);
          
          const geometry = new THREE.PlaneGeometry(width, panelHeight);
          const material = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.2,
            side: THREE.DoubleSide,
            wireframe: false
          });
          
          const mesh = new THREE.Mesh(geometry, material);
          mesh.position.set(x, y, z);
          
          // Додавання обводки до панелі
          const borderGeometry = new THREE.EdgesGeometry(geometry);
          const borderMaterial = new THREE.LineBasicMaterial({
            color: new THREE.Color().lerpColors(colorRosa, colorMorado, i / panelCount),
            linewidth: 2
          });
          const borderMesh = new THREE.LineSegments(borderGeometry, borderMaterial);
          mesh.add(borderMesh);
          
          const panel = {
            mesh: mesh,
            position: { x, y, z },
            index: i
          };
          
          panels.push(panel);
          scene.add(mesh);
        }
      };
      
      // Функція для створення та розташування fireflies у сцені
      const createFireflies = () => {
        // Видалення існуючих fireflies
        fireflies.forEach(f => scene.remove(f.sprite));
        fireflies.length = 0;
        
        for (let i = 0; i < fireflyCount; i++) {
          // Випадкове розташування у просторі
          const x = (Math.random() - 0.5) * 2000;
          const y = (Math.random() - 0.5) * 2000;
          const z = Math.random() * (panelCount * panelDepthSpacing * -1.5);
          
          const sprite = new THREE.Sprite(fireflyMaterial.clone());
          sprite.position.set(x, y, z);
          
          // Випадковий розмір firefly
          const baseSize = Math.random() * 4 + 2;
          sprite.scale.set(baseSize, baseSize, 1);
          
          // Анімація та змішування кольорів
          const colorMix = Math.random();
          sprite.material.color = new THREE.Color().lerpColors(colorRosa, colorMorado, colorMix);
          
          const firefly = {
            sprite: sprite,
            baseSize: baseSize,
            flickerSpeed: 0.5 + Math.random() * 2,
            flickerIntensity: 0.2 + Math.random() * 0.4,
            flickerPhase: Math.random() * Math.PI * 2,
            moveSpeed: {
              x: (Math.random() - 0.5) * 0.2,
              y: (Math.random() - 0.5) * 0.2,
              z: (Math.random() - 0.5) * 0.2
            },
            initialPosition: { x, y, z }
          };
          
          fireflies.push(firefly);
          scene.add(sprite);
        }
      };
      
      // Функція для оновлення fireflies залежно від часу
      const updateFireflies = (time) => {
        fireflies.forEach((firefly, i) => {
          const { sprite, baseSize, flickerSpeed, flickerIntensity, flickerPhase, moveSpeed, initialPosition } = firefly;
          
          const flicker = 1.0 + Math.sin(time * flickerSpeed + flickerPhase) * flickerIntensity;
          sprite.scale.set(baseSize * flicker, baseSize * flicker, 1);
          
          sprite.position.x += moveSpeed.x * Math.sin(time * 0.5 + i);
          sprite.position.y += moveSpeed.y * Math.cos(time * 0.3 + i);
          sprite.position.z += moveSpeed.z * Math.sin(time * 0.7 + i);
          
          if (Math.abs(sprite.position.x - initialPosition.x) > 50) moveSpeed.x *= -1;
          if (Math.abs(sprite.position.y - initialPosition.y) > 50) moveSpeed.y *= -1;
          if (Math.abs(sprite.position.z - initialPosition.z) > 50) moveSpeed.z *= -1;
          
          const distance = Math.abs(sprite.position.z - camera.position.z);
          const sizeFactor = Math.max(0.1, Math.min(1.5, 1000 / distance));
          sprite.material.opacity = Math.min(1, sizeFactor * 0.8);
        });
      };
      
      // Функція для оновлення камери на основі scroll
      const updateCamera = () => {
        const scrollRatio = scrollPosition / maxScroll;
        const targetIndex = Math.floor(scrollRatio * panelCount);
        const panelProgress = (scrollRatio * panelCount) % 1;
        
        if (targetIndex !== currentPanelIndex && targetIndex < panelCount) {
          currentPanelIndex = targetIndex;
        }
        
        const currentPanel = panels[currentPanelIndex];
        const nextPanel = panels[Math.min(currentPanelIndex + 1, panelCount - 1)];
        
        if (currentPanel && nextPanel) {
          const targetZ = currentPanel.position.z + (nextPanel.position.z - currentPanel.position.z) * panelProgress;
          targetCameraZ = targetZ + 200;
          camera.position.z += (targetCameraZ - camera.position.z) * 0.1;
        }
      };
      
      // --- Анімація та рендеринг ---
      camera.position.z = 400;
      const clock = new THREE.Clock();
      
      const animate = () => {
        requestAnimationFrame(animate);
        const time = clock.getElapsedTime();
        
        updateFireflies(time);
        updateCamera();
        
        camera.position.x += (Math.sin(time * 0.1) * 30 - camera.position.x) * 0.01;
        camera.position.y += (Math.cos(time * 0.15) * 20 - camera.position.y) * 0.01;
        camera.lookAt(0, 0, camera.position.z - 400);
        
        renderer.render(scene, camera);
      };
      
      // --- Обробники подій ---
      window.addEventListener('scroll', () => {
        scrollPosition = window.scrollY;
      });
      
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
      
      // --- Ініціалізація ---
      const lenis = new Lenis({
        autoRaf: true,
        lerp: 0.1
      });
      
      createPanels();
      createFireflies();
      animate();
    })();
  </script>
</body>
</html>
