<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>3D Fireflies with Floating Text</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://unpkg.com/lenis@1.2.3/dist/lenis.min.js"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Ubuntu:ital,wght@0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel="stylesheet">
  <style>
    @font-face {
      font-family: "ZENTRY";
      src: url("../font/ZENTRY-Regular.woff2") format("woff2");
      font-display: swap;
    }

    @font-face {
      font-family: "Roobert-Regular";
      src: url("../font/Roobert-Regular.woff2") format("woff2");
      font-display: swap;
    }



    body {
      margin: 0;
      background-color: #000;
      overflow-x: hidden;
      height: 20000px; /* Espacio amplio для scroll */
      font-family: Arial, sans-serif;
    }
    
    canvas {
      position: fixed;
      top: 0;
      left: 0;
      display: block;
      z-index: 1;
    }
  </style>
</head>
<body>
  
  <script>
    (function() {
      // --- Ініціалізація Three.js ---
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      document.body.appendChild(renderer.domElement);
      
      // Базові кольори
      const colorRosa = new THREE.Color(255 / 255, 150 / 255, 180 / 255);
      const colorMorado = new THREE.Color(180 / 255, 100 / 255, 255 / 255);
      
      // Змінні для управління scroll та анімацією
      const maxScroll = document.body.scrollHeight - window.innerHeight;
      let scrollPosition = 0;
      let targetCameraZ = 0;
      let currentPanelIndex = 0;
      
      // --- Налаштування fireflies ---
      const fireflyCount = 1000;
      const fireflies = [];
      
      // --- Текстові панелі ---
      const textPanels = [];
      const panelCount = 9;
      const panelDepthSpacing = 500;
      
      // Функція створення текстури для firefly
      const createFireflyTexture = () => {
        const canvas = document.createElement('canvas');
        canvas.width = canvas.height = 32;
        const ctx = canvas.getContext('2d');
        const gradient = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
        gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
        gradient.addColorStop(0.3, 'rgba(255, 255, 255, 0.8)');
        gradient.addColorStop(0.7, 'rgba(255, 255, 255, 0.3)');
        gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 32, 32);
        return canvas;
      };

      const fireflyTexture = new THREE.CanvasTexture(createFireflyTexture());
      
      // Material для fireflies
      const fireflyMaterial = new THREE.SpriteMaterial({
        map: fireflyTexture,
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthTest: false
      });
      
      // Тексти для панелей
      const panelTexts = [
        "Imagínate tener un amigo que siempre sabe lo que necesitas antes de que se lo pidas. Así es Neoma, el lente de contacto inteligente que te acompaña y te entiende como nadie más.",
        "La pregunta es..",
        "¿Por qué elegir Neoma?",
        "Porque Neoma conecta todos los aspectos de tu vida en un solo lugar, analizando tus datos de salud, finanzas y hábitos diarios para ofrecerte una visión completa de tu bienestar.",
        "Porque a diferencia de otras soluciones, nuestro lente no solo recopila información, sino que la transforma en predicciones personalizadas que realmente puedes usar para mejorar tu día a día.",
        "Porque cada consejo que recibes está diseñado específicamente para ti, basado en tus patrones únicos, no en estadísticas generales que poco tienen que ver con tu realidad.",
        "Porque Neoma es discreto y se integra perfectamente en tu vida, sin dispositivos adicionales que llevar encima o apps complicadas que aprender a usar.",
        "Con Neoma, no estás comprando un gadget más, estás invirtiendo en un compañero de vida que te ayudará a tomar las mejores decisiones para tu futuro, sea en el amor, las finanzas o la salud.",
        "Scroll para volver"
      ];
      
      // Повертає назву шрифту відповідно до індексу панелі
      const getFontFamily = (index) => {
        return (index === 1 || index === 2) ? 'ZENTRY' : 'Roobert-Regular';
      };

      // Функція створення текстової текстури із ще вищою чіткістю
      const createTextTexture = (text, isTitle) => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        // Підвищений множник для чіткості
        const ratio = window.devicePixelRatio * 10;

        const fontSize = isTitle ? 32 : 18;
        const lineHeight = fontSize * 1.4;
        const maxWidth = 350;

        // Встановлюємо шрифт: якщо isTitle – Georgia, інакше – Arial
        const chosenFont = isTitle ? "Georgia" : "Arial";
        ctx.font = `${isTitle ? 'bold ' : ''}${fontSize}px ${chosenFont}`;
        
        // Подальший код для розбиття тексту на рядки
        const words = text.split(' ');
        let lines = [];
        let currentLine = words[0];
        
        for (let i = 1; i < words.length; i++) {
          const testLine = currentLine + ' ' + words[i];
          const metrics = ctx.measureText(testLine);
          if (metrics.width > maxWidth) {
            lines.push(currentLine);
            currentLine = words[i];
          } else {
            currentLine = testLine;
          }
        }
        lines.push(currentLine);
        
        // Встановлюємо розміри canvas з урахуванням ratio
        canvas.width = maxWidth * ratio;
        canvas.height = (lines.length * lineHeight + 20) * ratio;
        
        // Масштабування для чіткості
        ctx.scale(ratio, ratio);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Повторно встановлюємо шрифт після масштабу
        ctx.font = `${isTitle ? 'bold ' : ''}${fontSize}px ${chosenFont}`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        // Створення градієнта для тексту
        const gradient = ctx.createLinearGradient(0, 0, maxWidth, 0);
        gradient.addColorStop(0, isTitle ? 'rgba(255, 150, 180, 1)' : 'rgba(255, 255, 255, 0.95)');
        gradient.addColorStop(1, isTitle ? 'rgba(180, 100, 255, 1)' : 'rgba(255, 255, 255, 0.95)');
        ctx.fillStyle = gradient;
        
        // Додавання glow-ефекту
        if (isTitle) {
          ctx.shadowColor = 'rgba(255, 150, 220, 0.8)';
          ctx.shadowBlur = 15;
        } else {
          ctx.shadowColor = 'rgba(255, 255, 255, 0.5)';
          ctx.shadowBlur = 7;
        }
        
        // Малювання тексту рядок за рядком
        lines.forEach((line, i) => {
          ctx.fillText(line, maxWidth / 2, (i + 0.5) * lineHeight + 10);
        });
        
        return canvas;
      };

      
      // Функція створення текстових панелей у 3D
      const createTextPanels = () => {
        textPanels.forEach(p => scene.remove(p.mesh));
        textPanels.length = 0;
        
        for (let i = 0; i < panelCount; i++) {
          let x = 0;
          if (i >= 3 && i <= 6) {
            x = ((i - 3) % 2 === 0) ? -150 : 150;
          }
          
          const y = 0;
          const z = -(i * panelDepthSpacing);
          const isTitle = (i === 1 || i === 2 || i === 8);
          const fontFamily = getFontFamily(i);
          const textCanvas = createTextTexture(panelTexts[i], isTitle);
          const textTexture = new THREE.CanvasTexture(textCanvas);
          
          const textMaterial = new THREE.MeshBasicMaterial({
            map: textTexture,
            transparent: true,
            side: THREE.DoubleSide,
            depthWrite: false,
            blending: THREE.AdditiveBlending
          });
          
          // Обрахунок розмірів площини за розмірами canvas
          const textAspect = textCanvas.width / textCanvas.height;
          const textWidth = 350;
          const textHeight = textWidth / textAspect;
          
          const textGeometry = new THREE.PlaneGeometry(textWidth, textHeight);
          const textMesh = new THREE.Mesh(textGeometry, textMaterial);
          textMesh.position.set(x, y, z);
          
          textPanels.push({
            mesh: textMesh,
            position: { x, y, z },
            index: i
          });
          scene.add(textMesh);
        }
      };
      
      // Функція створення fireflies
      const createFireflies = () => {
        fireflies.forEach(f => scene.remove(f.sprite));
        fireflies.length = 0;
        
        for (let i = 0; i < fireflyCount; i++) {
          const x = (Math.random() - 0.5) * 2000;
          const y = (Math.random() - 0.5) * 2000;
          const z = Math.random() * (panelCount * panelDepthSpacing * -1.5);
          
          const sprite = new THREE.Sprite(fireflyMaterial.clone());
          sprite.position.set(x, y, z);
          const baseSize = Math.random() * 4 + 4;
          sprite.scale.set(baseSize, baseSize, 1);
          
          const colorMix = Math.random();
          sprite.material.color = new THREE.Color().lerpColors(colorRosa, colorMorado, colorMix);
          
          fireflies.push({
            sprite: sprite,
            baseSize: baseSize,
            flickerSpeed: 0.5 + Math.random() * 2,
            flickerIntensity: 0.2 + Math.random() * 0.4,
            flickerPhase: Math.random() * Math.PI * 2,
            moveSpeed: {
              x: (Math.random() - 0.5) * 0.2,
              y: (Math.random() - 0.5) * 0.2,
              z: (Math.random() - 0.5) * 0.2
            },
            initialPosition: { x, y, z }
          });
          scene.add(sprite);
        }
      };
      
      // Оновлення fireflies
      const updateFireflies = (time) => {
        fireflies.forEach((firefly, i) => {
          const { sprite, baseSize, flickerSpeed, flickerIntensity, flickerPhase, moveSpeed, initialPosition } = firefly;
          const flicker = 1.0 + Math.sin(time * flickerSpeed + flickerPhase) * flickerIntensity;
          sprite.scale.set(baseSize * flicker, baseSize * flicker, 1);
          
          sprite.position.x += moveSpeed.x * Math.sin(time * 0.5 + i);
          sprite.position.y += moveSpeed.y * Math.cos(time * 0.3 + i);
          sprite.position.z += moveSpeed.z * Math.sin(time * 0.7 + i);
          
          if (Math.abs(sprite.position.x - initialPosition.x) > 50) moveSpeed.x *= -1;
          if (Math.abs(sprite.position.y - initialPosition.y) > 50) moveSpeed.y *= -1;
          if (Math.abs(sprite.position.z - initialPosition.z) > 50) moveSpeed.z *= -1;
          
          const distance = Math.abs(sprite.position.z - camera.position.z);
          const sizeFactor = Math.max(0.1, Math.min(1.5, 1000 / distance));
          sprite.material.opacity = Math.min(1, sizeFactor * 0.8);
        });
      };
      
      // Оновлення текстових панелей
      const updateTextPanels = (time) => {
        textPanels.forEach(panel => {
          const distance = Math.abs(panel.position.z - camera.position.z);
          if (distance < 500) {
            panel.mesh.material.opacity = Math.min(1, (500 - distance) / 200);
            panel.mesh.rotation.x = Math.sin(time * 0.2) * 0.05;
            panel.mesh.rotation.y = Math.sin(time * 0.3) * 0.05;
          } else {
            panel.mesh.material.opacity = 0;
          }
        });
      };
      
      // Оновлення камери
      const updateCamera = (time) => {
        const scrollRatio = scrollPosition / maxScroll;
        const targetIndex = Math.floor(scrollRatio * panelCount);
        const panelProgress = (scrollRatio * panelCount) % 1;
        
        if (targetIndex !== currentPanelIndex && targetIndex < panelCount) {
          currentPanelIndex = targetIndex;
        }
        
        const currentPanel = textPanels[currentPanelIndex];
        const nextPanel = textPanels[Math.min(currentPanelIndex + 1, panelCount - 1)];
        
        if (currentPanel && nextPanel) {
          const targetZ = currentPanel.position.z + (nextPanel.position.z - currentPanel.position.z) * panelProgress;
          targetCameraZ = targetZ + 200;
          camera.position.z += (targetCameraZ - camera.position.z) * 0.1;
        }
        
        updateTextPanels(time);
      };
      
      // Анімація та рендеринг
      camera.position.z = 400;
      const clock = new THREE.Clock();
      
      const animate = () => {
        requestAnimationFrame(animate);
        const time = clock.getElapsedTime();
        
        updateFireflies(time);
        updateCamera(time);
        
        camera.position.x += (Math.sin(time * 0.1) * 30 - camera.position.x) * 0.01;
        camera.position.y += (Math.cos(time * 0.15) * 20 - camera.position.y) * 0.01;
        camera.lookAt(0, 0, camera.position.z - 400);
        renderer.render(scene, camera);
      };
      
      // Обробники подій
      window.addEventListener('scroll', () => {
        scrollPosition = window.scrollY;
      });
      
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
      
      // Очікування завантаження шрифтів перед ініціалізацією
      const init = () => {
        createTextPanels();
        createFireflies();
        animate();
      };
      
      document.fonts.ready.then(init);
      
      // Ініціалізація Lenis
      const lenis = new Lenis({
        autoRaf: true,
        lerp: 0.1
      });
      
    })();
  </script>
</body>
</html>
